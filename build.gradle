/*
 * Bearsampp Module Shell - Gradle Build Script
 * 
 * This build script converts the Ant-based build process to Gradle while maintaining
 * all features, tasks, methods, and functions from the original build.xml.
 * 
 * Bundle Type: tools (unchanged)
 */

// ============================================================================
// PLUGINS
// ============================================================================

plugins {
    id 'base'
}

// ============================================================================
// PROPERTIES AND CONFIGURATION
// ============================================================================

// Load build.properties
def buildPropsFile = file('build.properties')
if (!buildPropsFile.exists()) {
    throw new GradleException("build.properties not found at: ${buildPropsFile.absolutePath}")
}

def buildProps = new Properties()
buildPropsFile.withInputStream { buildProps.load(it) }

// Bundle configuration from build.properties
ext.bundleName = buildProps.getProperty('bundle.name', 'shell')
ext.bundleRelease = buildProps.getProperty('bundle.release', 'r1')
ext.bundleType = buildProps.getProperty('bundle.type', 'tools')
ext.bundleFormat = buildProps.getProperty('bundle.format', '7z')

// Root/dev path configuration (same convention as other modules)
def rootDir = file("${projectDir}/..").canonicalFile
def devPath = file("${rootDir}/dev")

// Define project paths (align with bruno build)
ext.projectBasedir = projectDir.absolutePath
ext.rootDirPath = rootDir.absolutePath

// Build base path resolution priority:
// 1) build.properties (build.path)
// 2) Environment variable BEARSAMPP_BUILD_PATH
// 3) Default to {root}/bearsampp-build
def buildPathFromProps = (buildProps.getProperty('build.path', '') ?: '').trim()
def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
def defaultBuildPath = "${rootDir}/bearsampp-build"
ext.buildBasePath = buildPathFromProps ? buildPathFromProps : (buildPathFromEnv ? buildPathFromEnv : defaultBuildPath)

// Verify dev directory exists
if (!devPath.exists()) {
    throw new GradleException("Project 'dev' not found in ${devPath}")
}

println "Bearsampp dev found in ${devPath}"

// Shared bearsampp-build/tmp directory structure (align with bruno)
ext.buildTmpPath = file("${buildBasePath}/tmp")

// Backward compatible alias used elsewhere in this script
ext.bundleTmpPath = buildTmpPath

// Common sub-paths under tmp
ext.bundleTmpBuildPath = file("${buildTmpPath}/bundles_build/${bundleType}/${bundleName}")
ext.bundleTmpPrepPath  = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}")
ext.bundleTmpSrcPath   = file("${buildTmpPath}/bundles_src")

// Download and extract paths per-module
ext.bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}")
ext.bundleTmpExtractPath  = file("${buildTmpPath}/extract/${bundleName}")

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Get list of available bundle versions from bin/ and bin/archived/ directories
 */
def getAvailableVersions() {
    def versions = []
    
    // Check bin directory
    def binDir = file("${projectDir}/bin")
    if (binDir.exists()) {
        def binVersions = binDir.listFiles()
                ?.findAll { it.isDirectory() && it.name.startsWith("${bundleName}-") && it.name != 'archived' }
            ?.collect { it.name.replace("${bundleName}-", '') } ?: []
        versions.addAll(binVersions)
    }
    
    // Check bin/archived subdirectory
    def archivedDir = file("${projectDir}/bin/archived")
    if (archivedDir.exists()) {
        def archivedVersions = archivedDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith("${bundleName}-") }
            ?.collect { it.name.replace("${bundleName}-", '') } ?: []
        versions.addAll(archivedVersions)
    }
    
    // Remove duplicates and sort
    return versions.unique().sort()
}

/**
 * Find 7-Zip executable on the system
 */
def find7ZipExecutable() {
    // Check common installation paths
    def possiblePaths = [
        'C:/Program Files/7-Zip/7z.exe',
        'C:/Program Files (x86)/7-Zip/7z.exe',
        System.getenv('7Z_HOME') ? "${System.getenv('7Z_HOME')}/7z.exe" : null
    ].findAll { it != null }

    for (path in possiblePaths) {
        def exe = file(path)
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Try to find in PATH
    try {
        def process = new ProcessBuilder('where', '7z.exe')
            .redirectErrorStream(true)
            .start()
        
        def output = process.inputStream.text.trim()
        def exitCode = process.waitFor()
        
        if (exitCode == 0 && output) {
            def firstPath = output.split('\n')[0].trim()
            if (file(firstPath).exists()) {
                return firstPath
            }
        }
    } catch (Exception e) {
        // Ignore and return null
    }

    return null
}

/**
 * Download a file from URL with progress indication
 */
def downloadFile(String url, File destFile) {
    println "  Downloading from: ${url}"
    println "  Destination: ${destFile.name}"
    
    destFile.parentFile.mkdirs()
    
    def connection = new URL(url).openConnection()
    connection.setRequestProperty('User-Agent', 'Bearsampp-Build')
    
    def contentLength = connection.getContentLengthLong()
    def inputStream = connection.getInputStream()
    def outputStream = new FileOutputStream(destFile)
    
    def buffer = new byte[8192]
    def bytesRead
    def totalBytesRead = 0L
    
    while ((bytesRead = inputStream.read(buffer)) != -1) {
        outputStream.write(buffer, 0, bytesRead)
        totalBytesRead += bytesRead
        
        if (contentLength > 0) {
            def progress = (totalBytesRead * 100 / contentLength) as int
            if (progress % 10 == 0) {
                print "\r  Progress: ${progress}%"
            }
        }
    }
    
    println "\r  Progress: 100% - Complete"
    
    outputStream.close()
    inputStream.close()
    
    return destFile
}

/**
 * Download and extract a dependency from URL
 */
def downloadAndExtract(String url, File destDir) {
    // Use shared downloads cache directory
    def downloadsDir = file(bundleTmpDownloadPath)
    downloadsDir.mkdirs()
    
    // Determine filename from URL
    def filename = url.substring(url.lastIndexOf('/') + 1)
    def destFile = file("${downloadsDir}/${filename}")
    
    // Download if not already cached
    if (!destFile.exists()) {
        downloadFile(url, destFile)
    } else {
        println "  Using cached file: ${destFile.name}"
    }
    
    // Extract the archive
    println "  Extracting to: ${destDir.absolutePath}"
    destDir.mkdirs()
    
    if (filename.endsWith('.zip')) {
        // Extract ZIP file
        ant.unzip(src: destFile, dest: destDir, overwrite: true)
    } else if (filename.endsWith('.7z')) {
        // Extract 7z file
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("7-Zip not found. Required to extract .7z files.")
        }
        
        def command = [
            sevenZipExe,
            'x',
            destFile.absolutePath,
            "-o${destDir.absolutePath}",
            '-y'
        ]
        
        def process = new ProcessBuilder(command as String[])
            .redirectErrorStream(true)
            .start()
        
        process.inputStream.eachLine { line ->
            if (line.trim()) println "    ${line}"
        }
        
        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7zip extraction failed with exit code: ${exitCode}")
        }
    }
    
    return destDir
}

/**
 * PRIMARY source of versions/URLs: modules-untouched consolez.properties
 * Fallbacks: local releases.properties, then constructed standard URL
 */
def fetchModulesUntouchedProperties() {
    def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/${bundleName}.properties"

    println "Fetching ${bundleName}.properties from modules-untouched repository..."
    println "  URL: ${propsUrl}"

    def tempFile = file("${bundleTmpDownloadPath}/${bundleName}-untouched.properties")
    tempFile.parentFile.mkdirs()

    try {
        new URL(propsUrl).withInputStream { input ->
            tempFile.withOutputStream { output ->
                output << input
            }
        }
        def props = new Properties()
        tempFile.withInputStream { props.load(it) }
        println "  Successfully loaded ${props.size()} versions from modules-untouched"
        return props
    } catch (Exception e) {
        println "  Warning: Could not fetch ${bundleName}.properties from modules-untouched: ${e.message}"
        return null
    }
}

def downloadFromModulesUntouched(String name, String version) {
    println "Resolving URL for ${name} ${version}..."

    def untouchedProps = fetchModulesUntouchedProperties()
    def url = null
    if (untouchedProps) {
        url = untouchedProps.getProperty(version)
        if (url) {
            println "  Found in modules-untouched properties:\n  ${url}"
        } else {
            println "  Version ${version} not found in modules-untouched properties"
        }
    }

    // Fallback: local releases.properties (if present)
    if (!url) {
        def releasesFile = file('releases.properties')
        if (releasesFile.exists()) {
            def releases = new Properties()
            releasesFile.withInputStream { releases.load(it) }
            url = releases.getProperty(version)
            if (url) {
                println "  Found in local releases.properties:\n  ${url}"
            } else {
                println "  Version ${version} not found in local releases.properties"
            }
        } else {
            println "  Local releases.properties not found"
        }
    }

    // Fallback: construct standard URL (best-effort)
    if (!url) {
        // Best guess naming (may vary per module); inform the user
        def tag = "${name.capitalize()}-${bundleRelease}"
        def guessedFile = "${name}-${version}-win64.7z"
        url = "https://github.com/Bearsampp/modules-untouched/releases/download/${tag}/${guessedFile}"
        println "  Constructed fallback URL (verify manually if needed):\n  ${url}"
    }

    println "Downloading ${name} ${version}..."
    
    // Create shared download cache directory under bearsampp-build/tmp
    def downloadsDir = file(bundleTmpDownloadPath)
    downloadsDir.mkdirs()

    // Keep a small area for untouched archives if needed in the future
    def tempDir = file("${buildTmpPath}/untouched")
    tempDir.mkdirs()
    
    // Determine filename from URL
    def filename = url.substring(url.lastIndexOf('/') + 1)
    // Cache downloads in a stable location
    def destFile = file("${downloadsDir}/${filename}")
    
    // Download if not cached
    if (!destFile.exists()) {
        downloadFile(url, destFile)
    } else {
        println "Using cached file: ${destFile.name}"
    }
    
    // Extract to shared extract directory: bearsampp-build/tmp/extract/{bundleName}/{version}
    def extractDir = file("${bundleTmpExtractPath}/${version}")
    if (extractDir.exists()) {
        delete extractDir
    }
    extractDir.mkdirs()
    
    println "Extracting ${filename}..."
    
    if (filename.endsWith('.7z')) {
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("7-Zip not found. Required to extract module.")
        }
        
        def command = [
            sevenZipExe,
            'x',
            destFile.absolutePath,
            "-o${extractDir.absolutePath}",
            '-y'
        ]
        
        def process = new ProcessBuilder(command as String[])
            .redirectErrorStream(true)
            .start()
        
        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7zip extraction failed")
        }
    } else {
        ant.unzip(src: destFile, dest: extractDir, overwrite: true)
    }
    
    // Try to locate main Console.exe directory inside extracted tree
    return findConsolezDirectory(extractDir) ?: extractDir
}

// Find ConsoleZ directory containing Console.exe
def findConsolezDirectory(File extractPath) {
    def hasExe = { File dir -> new File(dir, 'Console.exe').exists() }
    if (!extractPath?.exists()) return null
    if (hasExe(extractPath)) return extractPath
    File found = null
    def stack = new ArrayDeque<File>()
    extractPath.listFiles()?.findAll { it.isDirectory() }?.each { stack.push(it) }
    while (!stack.isEmpty() && found == null) {
        def dir = stack.pop()
        if (hasExe(dir)) { found = dir; break }
        dir.listFiles()?.findAll { it.isDirectory() }?.each { stack.push(it) }
    }
    return found
}

// ============================================================================
// TASKS
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build information and available tasks'
    
    doLast {
        println """
        ================================================================
          Bearsampp Module Shell - Build Information
        ================================================================
        
        Bundle Configuration:
          Name:           ${bundleName}
          Release:        ${bundleRelease}
          Type:           ${bundleType}
          Format:         ${bundleFormat}
        
        Paths:
          Project:        ${projectDir}
          Dev:            ${devPath}
          Build Base:     ${buildBasePath}
          Build Tmp:      ${buildTmpPath}
          Tmp Prep:       ${bundleTmpPrepPath}
          Tmp Build:      ${bundleTmpBuildPath}
          Tmp Src:        ${bundleTmpSrcPath}
          Tmp Download:   ${bundleTmpDownloadPath}
          Tmp Extract:    ${bundleTmpExtractPath}
        
        Available Tasks:
          gradle info              - Show this information
          gradle listVersions      - List available bundle versions
          gradle listReleases      - List releases from modules-untouched
          gradle release           - Build release (use -PbundleVersion=X.X.X.X)
          gradle releaseAll        - Build all available versions
          gradle verify            - Verify build environment
          gradle validateProperties - Validate build.properties
          gradle checkDeps         - Check dependencies configuration
          gradle clean             - Clean build artifacts
        
        Examples:
          gradle release -PbundleVersion=1.19.0.19104
          gradle releaseAll
        
        ================================================================
        """.stripIndent()
    }
}

// Task: Build release for a specific version
tasks.register('release') {
    group = 'build'
    description = 'Build release package for a specific version (use -PbundleVersion=X.X.X.X)'
    
    // Capture property at configuration time to avoid deprecation warning
    def bundleVersionProperty = project.findProperty('bundleVersion')
    
    doLast {
        def versionToBuild = bundleVersionProperty
        
        // Interactive mode if no version specified
        if (!versionToBuild) {
            def versions = getAvailableVersions()
            
            if (versions.isEmpty()) {
                throw new GradleException("No versions found in bin/ or bin/archived/ directories")
            }
            
            println ""
            println "=".multiply(70)
            println "Available ${bundleName} versions:"
            println "=".multiply(70)
            
            // Show which directory each version is in
            def binDir = file("${projectDir}/bin")
            def archivedDir = file("${projectDir}/bin/archived")
            
            versions.eachWithIndex { version, index ->
                def location = ""
                if (binDir.exists() && file("${binDir}/${bundleName}-${version}").exists()) {
                    location = "[bin]"
                } else if (archivedDir.exists() && file("${archivedDir}/${bundleName}-${version}").exists()) {
                    location = "[bin/archived]"
                }
                println "  ${(index + 1).toString().padLeft(2)}. ${version.padRight(20)} ${location}"
            }
            println "=".multiply(70)
            println ""
            println "Enter version number or full version string: "
            println ""
            
            // Read input using Gradle's standard input
            def input = null
            try {
                def reader = new BufferedReader(new InputStreamReader(System.in))
                input = reader.readLine()
            } catch (Exception e) {
                throw new GradleException("""
                    Failed to read input. Please use non-interactive mode:
                      gradle release -PbundleVersion=X.X.X

                    Available versions: ${versions.join(', ')}
                """.stripIndent())
            }
            
            if (!input || input.trim().isEmpty()) {
                throw new GradleException("""
                    No version selected. Please use non-interactive mode:
                      gradle release -PbundleVersion=X.X.X

                    Available versions: ${versions.join(', ')}
                """.stripIndent())
            }
            
            input = input.trim()
            
            // Check if input is a number (index selection)
            if (input.isInteger()) {
                def index = input.toInteger() - 1
                if (index >= 0 && index < versions.size()) {
                    versionToBuild = versions[index]
                } else {
                    throw new GradleException("Invalid selection: ${input}. Please choose 1-${versions.size()}")
                }
            } else {
                // Direct version string
                versionToBuild = input
            }
            
            println ""
            println "Selected version: ${versionToBuild}"
        }
        
        println ""
        println "=".multiply(70)
        println "Building ${bundleName} ${versionToBuild} release"
        println "=".multiply(70)
        println ""
        
        // Check both bin/ and bin/archived/ directories
        def bundlePath = file("${projectDir}/bin/${bundleName}-${versionToBuild}")
        
        if (!bundlePath.exists()) {
            bundlePath = file("${projectDir}/bin/archived/${bundleName}-${versionToBuild}")
        }
        
        if (!bundlePath.exists()) {
            def allVersions = getAvailableVersions()
            def availableVersionsList = allVersions.collect { 
                "  - ${it}" 
            }.join('\n') ?: "  (none found)"
            
            throw new GradleException("""
                Bundle version not found: ${bundleName}-${versionToBuild}
                
                Available versions:
                ${availableVersionsList}
            """.stripIndent())
        }
        
        println "Bundle path: ${bundlePath}"
        println ""
        
        // Get the bundle folder and version
        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace("${bundleName}-", '')

        // Determine source paths
        def bundleSrcDest = bundlePath
        def bundleSrcFinal = bundleSrcDest

        // PowerShell binaries are never in bin/ - always download from modules-untouched
        println ""
        println "Downloading PowerShell ${bundleVersion}..."
        println ""

        try {
            // Always download fresh from modules-untouched (no cache)
            def tmpExtractPath = file("${bundleTmpExtractPath}/${bundleVersion}")
            if (tmpExtractPath.exists()) {
                delete tmpExtractPath
            }
            
            bundleSrcFinal = downloadFromModulesUntouched(bundleName, bundleVersion)
        } catch (Exception e) {
            throw new GradleException("""
                Failed to download PowerShell binaries: ${e.message}

                Check that version ${bundleVersion} exists in modules-untouched shell.properties
            """.stripIndent())
        }

        // Verify pwsh.exe exists
        def pwshExe = file("${bundleSrcFinal}/pwsh.exe")
        if (!pwshExe.exists()) {
            throw new GradleException("pwsh.exe not found at ${pwshExe}")
        }

        println "Source folder: ${bundleSrcFinal}"
        println ""
        
        // Process dependencies if deps.properties exists
        def depsFile = file("${bundlePath}/deps.properties")
        if (depsFile.exists()) {
            println ""
            println "Processing dependencies..."
            
            def depsProps = new Properties()
            depsFile.withInputStream { depsProps.load(it) }
            
            // ANSICON
            if (depsProps.containsKey('ansicon')) {
                println ""
                println "Download ANSICON"
                def ansiconUrl = depsProps.getProperty('ansicon')
                def ansiconPath = file("${bundleSrcFinal}/ansicon")
                
                def ansiconTempDir = downloadAndExtract(ansiconUrl, file("${bundleTmpPath}/ansicon-temp"))
                
                println "Check ANSICON"
                ansiconPath.mkdirs()
                copy {
                    from "${ansiconTempDir}/x86"
                    into ansiconPath
                }
                
                def ansiconExe = file("${ansiconPath}/ansicon.exe")
                if (!ansiconExe.exists()) {
                    throw new GradleException("ansicon.exe not found after extraction")
                }
                println "Verified: ansicon.exe"
            }
            
            // Clink
            if (depsProps.containsKey('clink')) {
                println ""
                println "Download Clink"
                def clinkUrl = depsProps.getProperty('clink')
                def clinkPath = file("${bundleSrcFinal}/vendor/clink")
                
                def clinkTempDir = downloadAndExtract(clinkUrl, file("${bundleTmpPath}/clink-temp"))
                
                // Extract basename from URL for subdirectory
                def clinkBasename = clinkUrl.substring(clinkUrl.lastIndexOf('/') + 1).replace('.zip', '')
                
                println "Check Clink"
                clinkPath.mkdirs()
                copy {
                    from "${clinkTempDir}/${clinkBasename}"
                    into clinkPath
                }
                
                def clinkBat = file("${clinkPath}/clink.bat")
                if (!clinkBat.exists()) {
                    throw new GradleException("clink.bat not found after extraction")
                }
                println "Verified: clink.bat"
            }
            
            // Clink completions
            if (depsProps.containsKey('clink_completions')) {
                println ""
                println "Download Clink completions"
                def clinkCompletionsUrl = depsProps.getProperty('clink_completions')
                def clinkCompletionsPath = file("${bundleSrcFinal}/vendor/clink-completions")
                
                def clinkCompletionsTempDir = downloadAndExtract(clinkCompletionsUrl, file("${bundleTmpPath}/clink-completions-temp"))
                
                // Extract basename from URL for subdirectory
                def clinkCompletionsBasename = clinkCompletionsUrl.substring(clinkCompletionsUrl.lastIndexOf('/') + 1).replace('.zip', '')
                
                println "Check Clink completions"
                clinkCompletionsPath.mkdirs()
                copy {
                    from "${clinkCompletionsTempDir}/${clinkCompletionsBasename}"
                    into clinkCompletionsPath
                }
                
                def clinkInitLua = file("${clinkCompletionsPath}/.init.lua")
                if (!clinkInitLua.exists()) {
                    throw new GradleException(".init.lua not found after extraction")
                }
                println "Verified: .init.lua"
            }
            
            // Oh My Posh
            if (depsProps.containsKey('oh_my_posh')) {
                println ""
                println "Download Oh My Posh"
                def ohMyPoshUrl = depsProps.getProperty('oh_my_posh')
                def ohMyPoshPath = file("${bundleSrcFinal}/vendor/oh-my-posh")
                
                println "Check Oh My Posh"
                ohMyPoshPath.mkdirs()
                
                // Determine filename from URL
                def filename = ohMyPoshUrl.substring(ohMyPoshUrl.lastIndexOf('/') + 1)
                def finalDestFile = file("${ohMyPoshPath}/oh-my-posh.exe")
                
                // Download if not already cached
                def downloadsDir = file(bundleTmpDownloadPath)
                downloadsDir.mkdirs()
                def cachedFile = file("${downloadsDir}/${filename}")
                
                if (!cachedFile.exists()) {
                    downloadFile(ohMyPoshUrl, cachedFile)
                } else {
                    println "  Using cached file: ${cachedFile.name}"
                }
                
                // Copy to destination and rename to oh-my-posh.exe
                copy {
                    from cachedFile
                    into ohMyPoshPath
                    rename { 'oh-my-posh.exe' }
                }
                
                if (!finalDestFile.exists()) {
                    throw new GradleException("oh-my-posh.exe not found after download")
                }
                println "Verified: oh-my-posh.exe"
            }
            
            // Oh My Posh Theme
            if (depsProps.containsKey('oh_my_posh_theme')) {
                println ""
                println "Download Oh My Posh Theme"
                def ohMyPoshThemeUrl = depsProps.getProperty('oh_my_posh_theme')
                def ohMyPoshThemePath = file("${bundleSrcFinal}/vendor/oh-my-posh/themes")
                
                println "Check Oh My Posh Theme"
                ohMyPoshThemePath.mkdirs()
                
                // Determine filename from URL
                def filename = ohMyPoshThemeUrl.substring(ohMyPoshThemeUrl.lastIndexOf('/') + 1)
                def destFile = file("${ohMyPoshThemePath}/${filename}")
                
                // Download if not already cached
                def downloadsDir = file(bundleTmpDownloadPath)
                downloadsDir.mkdirs()
                def cachedFile = file("${downloadsDir}/${filename}")
                
                if (!cachedFile.exists()) {
                    downloadFile(ohMyPoshThemeUrl, cachedFile)
                } else {
                    println "  Using cached file: ${cachedFile.name}"
                }
                
                // Copy to destination
                copy {
                    from cachedFile
                    into ohMyPoshThemePath
                }
                
                if (!destFile.exists()) {
                    throw new GradleException("${filename} not found after download")
                }
                println "Verified: ${filename}"
            }
            
            // GnuWin32 CoreUtils bin
            if (depsProps.containsKey('gnuwin32_coreutils_bin')) {
                println ""
                println "Download GnuWin32 CoreUtils bin"
                def gnuwin32BinUrl = depsProps.getProperty('gnuwin32_coreutils_bin')
                def gnuwin32Path = file("${bundleSrcFinal}/vendor/gnuwin32")
                
                def gnuwin32BinTempDir = downloadAndExtract(gnuwin32BinUrl, file("${bundleTmpPath}/gnuwin32-bin-temp"))
                
                println "Check GnuWin32 CoreUtils bin"
                gnuwin32Path.mkdirs()
                copy {
                    from "${gnuwin32BinTempDir}/bin"
                    into gnuwin32Path
                }
                
                def lsExe = file("${gnuwin32Path}/ls.exe")
                if (!lsExe.exists()) {
                    throw new GradleException("ls.exe not found after extraction")
                }
                println "Verified: ls.exe"
            }
            
            // GnuWin32 CoreUtils dep
            if (depsProps.containsKey('gnuwin32_coreutils_dep')) {
                println ""
                println "Download GnuWin32 CoreUtils dep"
                def gnuwin32DepUrl = depsProps.getProperty('gnuwin32_coreutils_dep')
                def gnuwin32Path = file("${bundleSrcFinal}/vendor/gnuwin32")
                
                def gnuwin32DepTempDir = downloadAndExtract(gnuwin32DepUrl, file("${bundleTmpPath}/gnuwin32-dep-temp"))
                
                println "Check GnuWin32 CoreUtils dep"
                gnuwin32Path.mkdirs()
                copy {
                    from "${gnuwin32DepTempDir}/bin"
                    into gnuwin32Path
                }
                
                def libintl3Dll = file("${gnuwin32Path}/libintl3.dll")
                if (!libintl3Dll.exists()) {
                    throw new GradleException("libintl3.dll not found after extraction")
                }
                println "Verified: libintl3.dll"
            }
        }
        
        println ""
        println "Preparing archive..."
        
        // Prepare output directory
        def consolezPrepPath = file("${bundleTmpPrepPath}/${bundleFolder}")
        if (consolezPrepPath.exists()) {
            delete consolezPrepPath
        }
        consolezPrepPath.mkdirs()
        
        // Copy all files to prep directory
        copy {
            from bundleSrcFinal
            into consolezPrepPath
        }
        
        // Copy bundle files again (overwrite)
        copy {
            from bundlePath
            into consolezPrepPath
            exclude 'deps.properties'
        }

        // Copy to bundles_build directory (non-zip dev artifact)
        println ""
        println "Copying to bundles_build directory..."
        def nonZipBuildPath = file("${bundleTmpBuildPath}/${bundleFolder}")
        if (nonZipBuildPath.exists()) {
            delete nonZipBuildPath
        }
        nonZipBuildPath.mkdirs()
        copy {
            from consolezPrepPath
            into nonZipBuildPath
        }
        println "Non-zip version available at: ${nonZipBuildPath}"
        
        // Determine build output path following Bearsampp pattern
        // bearsampp-build/{bundleType}/{bundleName}/{bundleRelease}
        def buildPath = file(buildBasePath)
        def buildBinsPath = file("${buildPath}/${bundleType}/${bundleName}/${bundleRelease}")
        buildBinsPath.mkdirs()
        
        // Build archive filename
        def destFile = file("${buildBinsPath}/bearsampp-${bundleName}-${bundleVersion}-${bundleRelease}")
        
        // Compress based on format
        if (bundleFormat == '7z') {
            // 7z format
            def archiveFile = file("${destFile}.7z")
            if (archiveFile.exists()) {
                delete archiveFile
            }
            
            println "Compressing ${bundleName}${bundleVersion} to ${archiveFile.name}..."
            
            // Find 7z executable
            def sevenZipExe = find7ZipExecutable()
            if (!sevenZipExe) {
                throw new GradleException("7-Zip not found. Please install 7-Zip or set 7Z_HOME environment variable.")
            }
            
            println "Using 7-Zip: ${sevenZipExe}"
            
            // Create 7z archive
            // Include the version folder itself, not only its contents
            def command = [
                sevenZipExe,
                'a',
                '-t7z',
                archiveFile.absolutePath.toString(),
                bundleFolder
            ]

            // Run from the prep parent directory so the folder is included at archive root
            def process = new ProcessBuilder(command as String[])
                .directory(bundleTmpPrepPath)
                .redirectErrorStream(true)
                .start()
            
            process.inputStream.eachLine { line ->
                if (line.trim()) println "  ${line}"
            }
            
            def exitCode = process.waitFor()
            if (exitCode != 0) {
                throw new GradleException("7zip compression failed with exit code: ${exitCode}")
            }
            
            println "Archive created: ${archiveFile}"
            
            // Generate hash files
            println "Generating hash files..."
            generateHashFiles(archiveFile)
            
        } else {
            // ZIP format
            def archiveFile = file("${destFile}.zip")
            if (archiveFile.exists()) {
                delete archiveFile
            }
            
            println "Compressing ${bundleName}${bundleVersion} to ${archiveFile.name}..."
            
            // Include the version folder itself, not only its contents
            ant.zip(destfile: archiveFile, basedir: bundleTmpPrepPath, includes: "${bundleFolder}/**")
            
            println "Archive created: ${archiveFile}"
            
            // Generate hash files
            println "Generating hash files..."
            generateHashFiles(archiveFile)
        }

        // -----------------------------------------------------------------
        // Cleanup temporary dependency extraction folders (align with Bruno)
        // These are only staging areas and should not persist after a build
        // -----------------------------------------------------------------
        println ""
        println "Cleaning temporary dependency folders..."
        def tempDirsToClean = [
            file("${buildTmpPath}/ansicon-temp"),
            file("${buildTmpPath}/clink-temp"),
            file("${buildTmpPath}/clink-completions-temp"),
            file("${buildTmpPath}/gnuwin32-bin-temp"),
            file("${buildTmpPath}/gnuwin32-dep-temp")
        ]

        tempDirsToClean.each { dir ->
            try {
                if (dir.exists()) {
                    delete dir
                    println "  Removed: ${dir}"
                }
            } catch (Exception e) {
                // Non-fatal: continue cleanup of other dirs
                println "  Warning: could not remove ${dir}: ${e.message}"
            }
        }

        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println "Output directory: ${nonZipBuildPath}"
        println "Archive: ${destFile}.${bundleFormat}"
        println "=".multiply(70)
    }
}

// Helper function to generate hash files
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }
    
    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash} ${file.name}\n"
    println "  Created: ${md5File.name}"
    
    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash} ${file.name}\n"
    println "  Created: ${sha1File.name}"
    
    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash} ${file.name}\n"
    println "  Created: ${sha256File.name}"
    
    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash} ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Task: Build all available versions
tasks.register('releaseAll') {
    group = 'build'
    description = 'Build release packages for all available versions in bin/ directory'
    
    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            throw new GradleException("bin/ directory not found")
        }
        
        def versions = getAvailableVersions()
        
        if (versions.isEmpty()) {
            throw new GradleException("No versions found in bin/ directory")
        }
        
        println ""
        println "=".multiply(70)
        println "Building releases for ${versions.size()} ${bundleName} versions"
        println "=".multiply(70)
        println ""
        
        def successCount = 0
        def failedVersions = []
        
        versions.each { version ->
            println "=".multiply(70)
            println "[${successCount + 1}/${versions.size()}] Building ${bundleName} ${version}..."
            println "=".multiply(70)
            
            try {
                // Execute release task for this version
                project.tasks.release.actions.each { action ->
                    project.ext.bundleVersion = version
                    action.execute(project.tasks.release)
                }
                
                println ""
                println "[SUCCESS] ${bundleName} ${version} completed"
                successCount++
                
            } catch (Exception e) {
                println ""
                println "[FAILED] ${bundleName} ${version}: ${e.message}"
                failedVersions.add(version)
            }
            
            println ""
        }
        
        // Summary
        println "=".multiply(70)
        println "Build Summary"
        println "=".multiply(70)
        println "Total versions: ${versions.size()}"
        println "Successful:     ${successCount}"
        println "Failed:         ${failedVersions.size()}"
        
        if (!failedVersions.isEmpty()) {
            println ""
            println "Failed versions:"
            failedVersions.each { v ->
                println "  - ${v}"
            }
        }
        
        println "=".multiply(70)
        
        if (failedVersions.isEmpty()) {
            println "[SUCCESS] All versions built successfully!"
        } else {
            throw new GradleException("${failedVersions.size()} version(s) failed to build")
        }
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'
    
    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
        }
        
        // Clean temp build directory
        if (bundleTmpPath.exists()) {
            delete bundleTmpPath
        }
        
        println "[SUCCESS] Build artifacts cleaned"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'
    
    doLast {
        println "Verifying build environment for module-consolez..."
        
        def checks = [:]
        
        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8
        
        // Check required files
        checks['build.properties'] = file('build.properties').exists()
        
        // Check dev directory
        checks['dev directory'] = file(devPath).exists()
        
        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()
        
        // Check 7-Zip if format is 7z
        if (bundleFormat == '7z') {
            checks['7-Zip'] = find7ZipExecutable() != null
        }
        
        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)
        
        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release -PbundleVersion=1.19.0.19104   - Build release for version"
            println "  gradle listVersions                            - List available versions"
            println "  gradle listReleases                            - List releases from modules-untouched"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// Task: List all bundle releases from modules-untouched properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from modules-untouched'
    
    doLast {
        def props = fetchModulesUntouchedProperties()
        if (!props) {
            println "\n[WARNING] Could not fetch modules-untouched properties."
            println "No release information available."
            return
        }

        println "\nAvailable ${bundleName.capitalize()} Releases (modules-untouched):"
        println "-".multiply(80)
        props.sort { a, b -> a.key <=> b.key }.each { version, url ->
            println "  ${version.padRight(15)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${props.size()}"
    }
}

// Task: Check modules-untouched integration for this module
tasks.register('checkModulesUntouched') {
    group = 'verification'
    description = 'Check modules-untouched repository integration and available versions'

    doLast {
        println ""
        println "=".multiply(70)
        println "Modules-Untouched Integration Check"
        println "=".multiply(70)
        println ""

        def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/${bundleName}.properties"
        println "Repository URL:"
        println "  ${propsUrl}"
        println ""

        println "Fetching ${bundleName}.properties from modules-untouched..."
        def untouchedProps = fetchModulesUntouchedProperties()

        if (untouchedProps) {
            println ""
            println "=".multiply(70)
            println "Available Versions in modules-untouched"
            println "=".multiply(70)

            def sortedVersions = untouchedProps.sort { a, b ->
                def aParts = a.key.tokenize('.')
                def bParts = b.key.tokenize('.')
                for (int i = 0; i < Math.min(aParts.size(), bParts.size()); i++) {
                    def aNum = aParts[i].toInteger()
                    def bNum = bParts[i].toInteger()
                    if (aNum != bNum) return aNum <=> bNum
                }
                return aParts.size() <=> bParts.size()
            }

            sortedVersions.each { version, url ->
                println "  ${version.padRight(10)}"
            }

            println "=".multiply(70)
            println "Total versions: ${untouchedProps.size()}"
            println ""

            println ""
            println "=".multiply(70)
            println "[SUCCESS] modules-untouched integration is working"
            println "=".multiply(70)
            println ""
            println "Version Resolution Strategy:"
            println "  1. Check modules-untouched ${bundleName}.properties (remote)"
            println "  2. Local releases.properties (fallback, if present)"
            println "  3. Construct standard URL format (last fallback)"
        } else {
            println ""
            println "=".multiply(70)
            println "[WARNING] Could not fetch ${bundleName}.properties from modules-untouched"
            println "=".multiply(70)
            println ""
            println "This may be due to network issues or file unavailability."
            println "The build will fall back to local releases.properties (if present) or a constructed URL."
        }
    }
}

// Task: List available bundle versions in bin and bin/archived directories
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ and bin/archived/ directories'
    
    // Capture at configuration time
    def name = bundleName
    
    doLast {
        def versions = getAvailableVersions()
        
        if (versions.isEmpty()) {
            println "\nNo versions found in bin/ or bin/archived/ directories"
            return
        }
        
        println "\nAvailable ${name} versions:"
        println "-".multiply(60)
        
        // Show which directory each version is in
        def binDir = file("${projectDir}/bin")
        def archivedDir = file("${projectDir}/bin/archived")
        
        versions.each { version ->
            def location = ""
            if (binDir.exists() && file("${binDir}/${name}${version}").exists()) {
                location = "[bin]"
            } else if (archivedDir.exists() && file("${archivedDir}/${name}${version}").exists()) {
                location = "[bin/archived]"
            }
            println "  ${version.padRight(20)} ${location}"
        }
        println "-".multiply(60)
        println "Total versions: ${versions.size()}"
        
        if (!versions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${versions.last()}"
        }
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'
    
    doLast {
        println "Validating build.properties..."
        
        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []
        
        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }
        
        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: Check ConsoleZ dependencies configuration
tasks.register('checkDeps') {
    group = 'verification'
    description = 'Check ConsoleZ dependencies configuration in bin directories'
    
    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }
        
        println "\nChecking ConsoleZ dependencies configuration..."
        println "-".multiply(80)
        
        def versions = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.sort { it.name } ?: []
        
        versions.each { versionDir ->
            def depsFile = new File(versionDir, 'deps.properties')
            if (depsFile.exists()) {
                def deps = new Properties()
                depsFile.withInputStream { deps.load(it) }
                println "\n${versionDir.name}:"
                println "  Dependencies file: Found (${deps.size()} dependencies)"
                deps.each { name, url ->
                    println "    - ${name}: ${url}"
                }
            } else {
                println "\n${versionDir.name}:"
                println "  Dependencies file: Not found"
            }
        }
        println "-".multiply(80)
    }
}

// Task: Download ConsoleZ package directly
tasks.register('downloadConsoleZ') {
    group = 'build'
    description = 'Download ConsoleZ package from modules-untouched (use -PconsolezVersion=X.X.X.X)'

    def consolezVersionProperty = project.findProperty('consolezVersion')

    doLast {
        def version = consolezVersionProperty
        if (!version) {
            throw new GradleException("Please specify consolez version: gradle downloadConsoleZ -PconsolezVersion=1.19.0.19104")
        }

        println "Downloading ConsoleZ ${version}..."
        def extractDir = downloadFromModulesUntouched(bundleName, version)
        println "[SUCCESS] Downloaded and extracted to: ${extractDir}"
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module Shell - Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
